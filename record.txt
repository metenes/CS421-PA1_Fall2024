import socket
import threading
import base64
import json
import os
import sys
import hashlib
import ssl
from urllib.parse import urlparse
import time
import zlib
from urllib.parse import urlparse
from datetime import datetime
from collections import defaultdict
import logging
from typing import Dict, List, Tuple, Optional
import queue
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from datetime import datetime
import time
import json
import requests
import threading
import math
import os
import subprocess

    # ----------------------------------------------------------------------------------------------------------------
    #  New GUI features  ---------------------------------------------------------------------------------------------
    #  Tkinter is a built-in Python standard library, so you don't have to download anything extra ------------------
    # ----------------------------------------------------------------------------------------------------------------
    # ----------------------------------------------------------------------------------------------------------------

class PseudoGitGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("PseudoGit GUI")
        self.root.geometry("800x600")
        
        # Create queues for thread-safe communication
        self.message_queue = queue.Queue()
        self.progress_queue = queue.Queue()
        
        # Track active operations
        self.active_operation = False
        
        self._create_gui()
        self._setup_periodic_updates()

    def _create_gui(self):
        """Create the main GUI elements"""
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Repository frame
        repo_frame = ttk.LabelFrame(main_frame, text="Repository Details", padding="5")
        repo_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Label(repo_frame, text="Repository:").grid(row=0, column=0, padx=5)
        self.repo_entry = ttk.Entry(repo_frame, width=40)
        self.repo_entry.grid(row=0, column=1, padx=5)
        ttk.Label(repo_frame, text="(e.g., username/repository)").grid(row=0, column=2, padx=5)
        
        ttk.Label(repo_frame, text="Branch:").grid(row=1, column=0, padx=5)
        self.branch_entry = ttk.Entry(repo_frame, width=40)
        self.branch_entry.grid(row=1, column=1, padx=5)
        self.branch_entry.insert(0, "main")
        
        # Operations frame
        op_frame = ttk.LabelFrame(main_frame, text="Operations", padding="5")
        op_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=5)
        
        # Clone frame
        clone_frame = ttk.Frame(op_frame)
        clone_frame.grid(row=0, column=0, pady=5)
        
        ttk.Label(clone_frame, text="Parallel Downloads:").grid(row=0, column=0, padx=5)
        self.parallel_var = tk.StringVar(value="4")
        parallel_spin = ttk.Spinbox(clone_frame, from_=1, to=8, width=5, textvariable=self.parallel_var)
        parallel_spin.grid(row=0, column=1, padx=5)
        
        ttk.Button(clone_frame, text="Clone Repository", 
                  command=self._start_clone).grid(row=0, column=2, padx=5)
        
        # Upload frame
        upload_frame = ttk.Frame(op_frame)
        upload_frame.grid(row=1, column=0, pady=5)
        
        self.file_path = tk.StringVar()
        ttk.Label(upload_frame, text="File:").grid(row=0, column=0, padx=5)
        ttk.Entry(upload_frame, textvariable=self.file_path, width=40).grid(row=0, column=1, padx=5)
        ttk.Button(upload_frame, text="Browse", 
                  command=self._browse_file).grid(row=0, column=2, padx=5)
        ttk.Button(upload_frame, text="Upload File", 
                  command=self._start_upload).grid(row=0, column=3, padx=5)
        
        # Pull Request frame
        pr_frame = ttk.Frame(op_frame)
        pr_frame.grid(row=2, column=0, pady=5)
        
        ttk.Button(pr_frame, text="Create PR", 
                  command=self._create_pr).grid(row=0, column=0, padx=5)
        ttk.Button(pr_frame, text="List PRs", 
                  command=self._list_prs).grid(row=0, column=1, padx=5)
        
        # Progress frame
        progress_frame = ttk.LabelFrame(main_frame, text="Progress", padding="5")
        progress_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(progress_frame, mode='determinate', 
                                          variable=self.progress_var)
        self.progress_bar.grid(row=0, column=0, sticky=(tk.W, tk.E), padx=5, pady=5)
        
        # Log frame
        log_frame = ttk.LabelFrame(main_frame, text="Log", padding="5")
        log_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        self.log_text = tk.Text(log_frame, height=10, width=70)
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        scrollbar = ttk.Scrollbar(log_frame, orient=tk.VERTICAL, command=self.log_text.yview)
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        self.log_text.configure(yscrollcommand=scrollbar.set)
        
        # Configure grid weights
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(3, weight=1)
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)

    def _setup_periodic_updates(self):
        """Setup periodic GUI updates"""
        def update_gui():
            # Process any pending messages
            while True:
                try:
                    message = self.message_queue.get_nowait()
                    self._append_log(message)
                except queue.Empty:
                    break
                    
            # Process progress updates
            while True:
                try:
                    progress = self.progress_queue.get_nowait()
                    self.progress_var.set(progress)
                except queue.Empty:
                    break
                    
            # Schedule next update
            self.root.after(100, update_gui)
            
        update_gui()

    def _append_log(self, message: str):
        """Append message to log with timestamp"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.log_text.insert(tk.END, f"[{timestamp}] {message}\n")
        self.log_text.see(tk.END)

    def _browse_file(self):
        """Open file browser dialog"""
        filename = filedialog.askopenfilename()
        if filename:
            self.file_path.set(filename)

    def _validate_inputs(self) -> bool:
        """Validate required inputs"""
        if not self.repo_entry.get():
            messagebox.showerror("Error", "Please enter a repository name")
            return False
        if not self.branch_entry.get():
            messagebox.showerror("Error", "Please enter a branch name")
            return False
        return True

    def _start_operation(self, operation):
        """Start a background operation"""
        if self.active_operation:
            messagebox.showerror("Error", "An operation is already in progress")
            return False
        
        if not self._validate_inputs():
            return False
            
        self.active_operation = True
        self.progress_var.set(0)
        return True

    def _end_operation(self):
        """End the current operation"""
        self.active_operation = False
        self.progress_var.set(100)

    def _start_clone(self):
        """Start clone operation"""
        if not self._start_operation("clone"):
            return
            
        def clone_thread():
            try:
                from PseudoGit import PseudoGit
                
                client = PseudoGit(
                    command="clone",
                    repository=self.repo_entry.get(),
                    branch=self.branch_entry.get(),
                    parallel_count=self.parallel_var.get()
                )
                
                # Override client's print function to use our message queue
                def custom_print(msg):
                    self.message_queue.put(str(msg))
                client._print = custom_print
                
                # Start clone operation
                client.smart_clone()
                
                self.message_queue.put("Clone operation completed successfully")
            except Exception as e:
                self.message_queue.put(f"Error during clone: {str(e)}")
            finally:
                self._end_operation()
        
        threading.Thread(target=clone_thread, daemon=True).start()

    def _start_upload(self):
        """Start upload operation"""
        if not self._start_operation("upload"):
            return
            
        if not self.file_path.get():
            messagebox.showerror("Error", "Please select a file to upload")
            self._end_operation()
            return
            
        def upload_thread():
            try:
                from PseudoGit import PseudoGit
                
                client = PseudoGit(
                    command="upload",
                    repository=self.repo_entry.get(),
                    branch=self.branch_entry.get(),
                    file_name=self.file_path.get()
                )
                
                # Override client's print function
                def custom_print(msg):
                    self.message_queue.put(str(msg))
                client._print = custom_print
                
                # Start upload operation
                client.upload()
                
                self.message_queue.put("Upload completed successfully")
            except Exception as e:
                self.message_queue.put(f"Error during upload: {str(e)}")
            finally:
                self._end_operation()
        
        threading.Thread(target=upload_thread, daemon=True).start()

    def _create_pr(self):
        """Create pull request"""
        if not self._start_operation("create-pr"):
            return
            
        def pr_thread():
            try:
                from PseudoGit import PseudoGit
                
                client = PseudoGit(
                    command="create-pr",
                    repository=self.repo_entry.get(),
                    branch=self.branch_entry.get()
                )
                
                def custom_print(msg):
                    self.message_queue.put(str(msg))
                client._print = custom_print
                
                client.create_pr()
            except Exception as e:
                self.message_queue.put(f"Error creating PR: {str(e)}")
            finally:
                self._end_operation()
        
        threading.Thread(target=pr_thread, daemon=True).start()

    def _list_prs(self):
        """List pull requests"""
        if not self._start_operation("list-pr"):
            return
            
        def list_thread():
            try:
                from PseudoGit import PseudoGit
                
                client = PseudoGit(
                    command="list-pr",
                    repository=self.repo_entry.get()
                )
                
                def custom_print(msg):
                    self.message_queue.put(str(msg))
                client._print = custom_print
                
                client.list_pr()
            except Exception as e:
                self.message_queue.put(f"Error listing PRs: {str(e)}")
            finally:
                self._end_operation()
        
        threading.Thread(target=list_thread, daemon=True).start()

    # ----------------------------------------------------------------------------------------------------------------
    # New feature for Functinality ----------------------------------------------------------------------------------- 
    # ----------------------------------------------------------------------------------------------------------------

    def commit_visualizer(commits):
        """
        Visualizes commit history as a directed graph.
        
        Parameters:
            commits (list): A list of commit dictionaries, each containing commit SHA, message, 
                            and parent SHA(s).
        """
        import networkx as nx
        import matplotlib.pyplot as plt

        # Initialize a directed graph
        G = nx.DiGraph()

        # Add nodes and edges based on commits and parent relationships
        for commit in commits:
            sha = commit["sha"]
            message = commit["message"]
            G.add_node(sha, label=message[:30])

            for parent_sha in commit.get("parents", []):
                G.add_edge(parent_sha, sha)

        # Draw the graph
        pos = nx.spring_layout(G)  # Layout for better visualization
        labels = {node: G.nodes[node]["label"] for node in G.nodes}
        
        plt.figure(figsize=(12, 8))
        nx.draw(G, pos, with_labels=True, labels=labels, node_size=1500, node_color="skyblue", font_size=10)
        plt.title("Commit History Visualization")
        plt.show()

    def conflict_resolution_tool(base_branch_content, feature_branch_content):
        """
        Detects and resolves conflicts between two versions of a file.
        
        Parameters:
            base_branch_content (str): The content of the file in the base branch.
            feature_branch_content (str): The content of the file in the feature branch.
        
        Returns:
            str: The merged content after resolving conflicts.
        """
        from difflib import ndiff

        # Calculate differences
        base_lines = base_branch_content.splitlines()
        feature_lines = feature_branch_content.splitlines()
        
        diff = list(ndiff(base_lines, feature_lines))
        merged_content = []
        conflict_block = []
        in_conflict = False

        print("Starting conflict resolution...\n")

        for line in diff:
            if line.startswith("?"):  # ignore helper lines
                continue
            elif line.startswith("- "):
                if not in_conflict:
                    conflict_block = []
                    in_conflict = True
                conflict_block.append(f"Base: {line[2:]}")
            elif line.startswith("+ "):
                if in_conflict:
                    conflict_block.append(f"Feature: {line[2:]}")
                    # Display conflict to the user
                    print("\nConflict detected:")
                    for conflict_line in conflict_block:
                        print(conflict_line)

                    # Let user resolve conflict manually
                    resolution = input("Choose resolution [B]ase/[F]eature/[C]ustom: ").strip().upper()
                    if resolution == "B":
                        merged_content.append(conflict_block[0][6:])
                    elif resolution == "F":
                        merged_content.append(conflict_block[1][9:])
                    elif resolution == "C":
                        custom_resolution = input("Enter custom resolution: ")
                        merged_content.append(custom_resolution)
                    else:
                        print("Invalid option. Skipping this conflict.")
                    in_conflict = False
                else:
                    merged_content.append(line[2:])
            else:
                merged_content.append(line[2:])

        print("Conflict resolution completed.\n")
        return "\n".join(merged_content)
    
    def real_time_activity_monitor(repository, token):
        """
        Monitors GitHub activity in real-time by polling for updates.
        
        Parameters:
            repository (str): The repository in "owner/repo" format.
            token (str): The GitHub access token for authentication.
        """
        headers = {"Authorization": f"Bearer {token}", "Accept": "application/vnd.github.v3+json"}
        last_seen_events = set()

        print("Starting real-time activity monitor...\n")

        while True:
            try:
                # Check for new events
                response = requests.get(f"https://api.github.com/repos/{repository}/events", headers=headers)
                events = response.json()

                for event in events:
                    event_id = event["id"]
                    if event_id not in last_seen_events:
                        # Print new event details
                        event_type = event["type"]
                        actor = event["actor"]["login"]
                        repo_name = event["repo"]["name"]
                        print(f"[{event_type}] {actor} in {repo_name}")

                        # Update seen events
                        last_seen_events.add(event_id)

                # Limit the number of stored event IDs
                if len(last_seen_events) > 100:
                    last_seen_events = set(list(last_seen_events)[-100:])

                # Sleep before next poll
                time.sleep(10)
            except KeyboardInterrupt:
                print("\nReal-time activity monitor stopped.")
                break
            except Exception as e:
                print(f"Error: {e}")
                time.sleep(10)

    class GitHookSimulator:
        """
        Simulates Git hooks by running custom functions at specific stages in the Git workflow.
        """

        def __init__(self):
            self.hooks = {
                "pre-commit": [],
                "post-merge": [],
                # Additional hooks can be added here
            }

        def add_hook(self, hook_type, hook_function):
            """
            Adds a function to a specific Git hook.

            Parameters:
                hook_type (str): Type of hook (e.g., 'pre-commit', 'post-merge').
                hook_function (function): The function to add as a hook.
            """
            if hook_type in self.hooks:
                self.hooks[hook_type].append(hook_function)
                print(f"Hook added to {hook_type}")
            else:
                print(f"Invalid hook type: {hook_type}")

        def run_hooks(self, hook_type):
            """
            Executes all functions registered to a specific Git hook.

            Parameters:
                hook_type (str): Type of hook to run.
            """
            if hook_type in self.hooks:
                print(f"Running {hook_type} hooks...")
                for hook in self.hooks[hook_type]:
                    try:
                        hook()
                    except Exception as e:
                        print(f"Error running {hook_type} hook: {e}")
            else:
                print(f"No hooks defined for {hook_type}")


    def network_load_balanced_download(url, file_name, file_size, parallel_count):
        """
        Distributes file download across multiple connections for improved speed.
        
        Parameters:
            url (str): The URL of the file to download.
            file_name (str): The name of the file to save.
            file_size (int): The total size of the file.
            parallel_count (int): The number of connections to use for downloading.
        """
        chunk_size = math.ceil(file_size / parallel_count)
        threads = []

        # Function to download each chunk
        def download_chunk(start, end, chunk_id):
            try:
                headers = {"Range": f"bytes={start}-{end}"}
                response = requests.get(url, headers=headers, stream=True)
                if response.status_code == 206:
                    with open(file_name, "r+b") as f:
                        f.seek(start)
                        f.write(response.content)
                print(f"Chunk {chunk_id} downloaded: bytes {start}-{end}")
            except Exception as e:
                print(f"Failed to download chunk {chunk_id}: {e}")

        # Create file and set size
        with open(file_name, "wb") as f:
            f.truncate(file_size)

        # Start threads for each chunk
        for i in range(parallel_count):
            start = i * chunk_size
            end = min(start + chunk_size - 1, file_size - 1)
            thread = threading.Thread(target=download_chunk, args=(start, end, i))
            threads.append(thread)
            thread.start()

        # Wait for all threads to finish
        for thread in threads:
            thread.join()

        print("File downloaded successfully with network load balancing.")

    # Samples for Hooks
    def linter_check():
        print("Running linter check...")
        # Simulate running a linter
        result = subprocess.run(["echo", "Linting code..."], capture_output=True, text=True)
        print(result.stdout)

    def test_runner():
        print("Running tests...")
        # Simulate running tests
        result = subprocess.run(["echo", "Running tests..."], capture_output=True, text=True)
        print(result.stdout)

    # ----------------------------------------------------------------------------------------------------------------
    # New feature for Functinality Ends ------------------------------------------------------------------------------ 
    # ----------------------------------------------------------------------------------------------------------------

    # ----------------------------------------------------------------------------------------------------------------
    # New Features Ends, Base Code Starts ----------------------------------------------------------------------------
    # ----------------------------------------------------------------------------------------------------------------

class GitObject:
    def __init__(self, type_: str, content: bytes):
        self.type = type_
        self.content = content
        self.hash = self._calculate_hash()

    def _calculate_hash(self) -> str:
        """Calculate SHA-1 hash of the object"""
        header = f"{self.type} {len(self.content)}".encode()
        store = header + b'\x00' + self.content
        return hashlib.sha1(store).hexdigest()

    def serialize(self) -> bytes:
        """Serialize and compress the object"""
        header = f"{self.type} {len(self.content)}".encode()
        store = header + b'\x00' + self.content
        return zlib.compress(store)
    
# Root Code 
class PseudoGit:
    GITHUB_API_HOST = "api.github.com"
    GITHUB_REPO_HOST = "github.com"
    GITHUB_RAW_HOST = "raw.githubusercontent.com"  
    GITHUB_API_PORT = 443

    def __init__(self, command, repository, branch=None, file_name=None, pr_number=None, parallel_count=1):
        self.command = command
        self.repository = repository
        self.branch_id = branch if branch and branch != "None" else "main"
        self.file_name = file_name
        self.pr_number = pr_number
        self.parallel_count = parallel_count
        self.token = self.load_token()
        self.headers = self._auth_headers()
        
        # New features -----------------------------------------------------------------------------------
        self.object_store: Dict[str, GitObject] = {}
        self.download_queue = queue.Queue()
        self.upload_queue = queue.Queue()
        self.rate_limit_remaining = float('inf')
        self.rate_limit_reset = 0
        self.download_stats = defaultdict(lambda: {'bytes': 0, 'time': 0})
        
        # Setup logging
        self._setup_logging()
    def _setup_logging(self):
        """Setup logging configuration"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(levelname)s] %(message)s',
            handlers=[
                logging.FileHandler('pseudogit.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)

    def _rate_limit_handler(func):
        """Decorator to handle GitHub API rate limiting"""
        def wrapper(self, *args, **kwargs):
            while True:
                if self.rate_limit_remaining <= 1:
                    wait_time = self.rate_limit_reset - time.time()
                    if wait_time > 0:
                        self.logger.warning(f"Rate limit reached. Waiting {wait_time:.2f} seconds...")
                        time.sleep(wait_time)
                
                try:
                    return func(self, *args, **kwargs)
                except Exception as e:
                    if "rate limit exceeded" in str(e).lower():
                        header, _ = self._send_request("GET", "/rate_limit")
                        self._update_rate_limits(header)
                        continue
                    raise
        return wrapper

    def _update_rate_limits(self, header: str):
        """Update rate limit information from response headers"""
        for line in header.split('\r\n'):
            if line.startswith('X-RateLimit-Remaining:'):
                self.rate_limit_remaining = int(line.split(': ')[1])
            elif line.startswith('X-RateLimit-Reset:'):
                self.rate_limit_reset = int(line.split(': ')[1])

    def _calculate_file_hash(self, file_path: str) -> str:
        """Calculate SHA-1 hash of a file"""
        sha1 = hashlib.sha1()
        with open(file_path, 'rb') as f:
            while chunk := f.read(8192):
                sha1.update(chunk)
        return sha1.hexdigest()

    @_rate_limit_handler
    def smart_clone(self):
        """Enhanced clone with parallel processing, progress tracking, and resume capability"""
        self.logger.info(f"Starting smart clone of repository: {self.repository}")
        
        # Get repository structure
        tree = self._fetch_repository_tree()
        if not tree:
            return

        # Create download manifest
        manifest_file = f"{self.repository.split('/')[-1]}_manifest.json"
        manifest = self._load_manifest(manifest_file)
        
        # Prepare download queue
        for item in tree:
            if item['type'] == 'file':
                file_path = item['path']
                if not self._should_download(file_path, manifest):
                    continue
                self.download_queue.put(item)

        # Start download threads
        threads = []
        for _ in range(int(self.parallel_count)):
            t = threading.Thread(target=self._smart_download_worker)
            t.daemon = True
            t.start()
            threads.append(t)

        # Start progress monitor
        monitor_thread = threading.Thread(target=self._progress_monitor)
        monitor_thread.daemon = True
        monitor_thread.start()

        # Wait for completion
        self.download_queue.join()
        
        # Save final manifest
        self._save_manifest(manifest_file)
        
        # Print statistics
        self._print_clone_stats()

    def _smart_download_worker(self):
        """Worker thread for parallel downloads with error handling and retries"""
        while True:
            try:
                item = self.download_queue.get_nowait()
            except queue.Empty:
                break

            retries = 3
            while retries > 0:
                try:
                    self._download_with_verification(item)
                    break
                except Exception as e:
                    retries -= 1
                    if retries == 0:
                        self.logger.error(f"Failed to download {item['path']}: {e}")
                    else:
                        time.sleep(1)

            self.download_queue.task_done()

    def _download_with_verification(self, item: dict):
        """Download file with integrity verification and better error handling"""
        start_time = time.time()
        
        file_path = item['path']
        os.makedirs(os.path.dirname(file_path) if os.path.dirname(file_path) else '.', exist_ok=True)

        download_url = item.get('download_url')
        if not download_url:
            self.logger.error(f"No download URL for {file_path}")
            return

        # Download file
        header, content = self._send_request("GET", download_url)
        if not content:
            raise Exception("Download failed - no content received")

        # Convert string content to bytes if necessary
        if isinstance(content, str):
            content = content.encode()

        # Calculate hash of the raw content
        content_hash = hashlib.sha1(content).hexdigest()
        
        # Get the expected SHA from the item
        expected_sha = item.get('sha')
        
        # Compare hashes only if expected_sha is provided
        if expected_sha and content_hash != expected_sha:
            self.logger.warning(f"Hash mismatch for {file_path}")
            self.logger.debug(f"Expected: {expected_sha}")
            self.logger.debug(f"Got: {content_hash}")
            
            # Try to get the file content directly from the API
            api_path = f"/repos/{self.repository}/contents/{file_path}"
            if self.branch_id:
                api_path += f"?ref={self.branch_id}"
            
            header, api_response = self._send_request("GET", api_path)
            
            if api_response:
                try:
                    if isinstance(api_response, bytes):
                        api_response = api_response.decode()
                        
                    file_data = json.loads(api_response)
                    if file_data.get('content'):
                        content = base64.b64decode(file_data['content'])
                        content_hash = hashlib.sha1(content).hexdigest()
                        
                        if content_hash == expected_sha:
                            self.logger.info(f"Successfully retrieved correct content for {file_path} via API")
                        else:
                            self.logger.warning(f"Hash still mismatches after API retrieval for {file_path}")
                except Exception as e:
                    self.logger.error(f"Error retrieving file via API: {e}")

        # Save file
        try:
            with open(file_path, 'wb') as f:
                f.write(content)
        except Exception as e:
            self.logger.error(f"Error saving file {file_path}: {e}")
            raise

        # Update statistics
        elapsed = time.time() - start_time
        self.download_stats[file_path] = {
            'bytes': len(content),
            'time': elapsed
        }

    def _progress_monitor(self):
        """Monitor and display download progress"""
        total_files = self.download_queue.qsize()
        downloaded_files = 0
        last_update = time.time()

        while downloaded_files < total_files:
            current_size = self.download_queue.qsize()
            downloaded_files = total_files - current_size
            
            if time.time() - last_update >= 1:  # Update every second
                speed = sum(s['bytes'] for s in self.download_stats.values()) / \
                       max(sum(s['time'] for s in self.download_stats.values()), 0.001)
                
                sys.stdout.write(f"\rProgress: {downloaded_files}/{total_files} files " + 
                               f"({downloaded_files/total_files*100:.1f}%) " +
                               f"Speed: {speed/1024/1024:.2f} MB/s")
                sys.stdout.flush()
                last_update = time.time()
            
            time.sleep(0.1)

    def _fetch_repository_tree(self) -> List[dict]:
        """Fetch complete repository tree recursively"""
        def fetch_tree_recursive(path: str) -> List[dict]:
            api_path = f"/repos/{self.repository}/contents/{path}"
            if self.branch_id:
                api_path += f"?ref={self.branch_id}"

            header, body = self._send_request("GET", api_path)
            if not body:
                return []

            try:
                items = json.loads(body) if isinstance(body, str) else json.loads(body.decode())
                if not isinstance(items, list):
                    return [items]

                result = []
                for item in items:
                    if item['type'] == 'dir':
                        result.extend(fetch_tree_recursive(item['path']))
                    else:
                        result.append(item)
                return result
            except Exception as e:
                self.logger.error(f"Error fetching tree: {e}")
                return []

        return fetch_tree_recursive("")

    def _load_manifest(self, manifest_file: str) -> Dict:
        """Load download manifest"""
        try:
            with open(manifest_file, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}

    def _save_manifest(self, manifest_file: str):
        """Save download manifest"""
        manifest = {
            'repository': self.repository,
            'branch': self.branch_id,
            'last_update': datetime.now().isoformat(),
            'files': {
                path: {
                    'hash': self._calculate_file_hash(path),
                    'size': os.path.getsize(path),
                    'timestamp': os.path.getmtime(path)
                }
                for path in self.download_stats.keys()
            }
        }
        
        with open(manifest_file, 'w') as f:
            json.dump(manifest, f, indent=2)

    def _should_download(self, file_path: str, manifest: Dict) -> bool:
        """Determine if file should be downloaded based on manifest"""
        if not os.path.exists(file_path):
            return True

        file_info = manifest.get('files', {}).get(file_path, {})
        if not file_info:
            return True

        current_hash = self._calculate_file_hash(file_path)
        return current_hash != file_info.get('hash')

    def _print_clone_stats(self):
        """Print clone operation statistics"""
        total_bytes = sum(s['bytes'] for s in self.download_stats.values())
        total_time = max(sum(s['time'] for s in self.download_stats.values()), 0.001)
        avg_speed = total_bytes / total_time

        print("\n\nClone Statistics:")
        print(f"Total files: {len(self.download_stats)}")
        print(f"Total data: {total_bytes/1024/1024:.2f} MB")
        print(f"Total time: {total_time:.2f} seconds")
        print(f"Average speed: {avg_speed/1024/1024:.2f} MB/s")

    # ----------------------------------------------------------------------------------------------------------------
    # New features ---------------------------------------------------------------------------------------------------
    # ----------------------------------------------------------------------------------------------------------------


    def _get_file_info(self, file_path):
        """Get local file information"""
        try:
            return os.path.exists(file_path), os.path.getsize(file_path) if os.path.exists(file_path) else 0
        except OSError:
            return False, 0

    def load_token(self):
        try:
            with open("token.txt", "r") as file:
                return file.read().strip()
        except FileNotFoundError:
            print("Error: token.txt file not found. Please create it with your GitHub token.")
            sys.exit(1)

    def _auth_headers(self):
        return {
            "Authorization": f"token {self.token}",
            "User-Agent": "PseudoGitClient",
            "Accept": "application/vnd.github.v3+json"
        }

    def _send_request(self, method, url_or_path, headers=None, body=""):
        """Enhanced request sending with better error handling and automatic retries"""
        headers = headers or {}
        headers.update(self.headers)
        
        if url_or_path.startswith('http'):
            parsed_url = urlparse(url_or_path)
            host = parsed_url.netloc
            path = parsed_url.path
            if parsed_url.query:
                path += '?' + parsed_url.query
        else:
            host = self.GITHUB_API_HOST
            path = url_or_path if url_or_path.startswith('/') else '/' + url_or_path

        if host == self.GITHUB_RAW_HOST:
            headers.pop("Authorization", None)
            headers.pop("Accept", None)
        
        headers["Host"] = host
        
        if isinstance(body, str):
            body = body.encode()
        
        headers_str = "".join([f"{k}: {v}\r\n" for k, v in headers.items()])
        request = f"{method} {path} HTTP/1.1\r\n{headers_str}Connection: close\r\nContent-Length: {len(body)}\r\n\r\n".encode()
        if body:
            request += body

        max_retries = 3
        retry_delay = 1
        
        for attempt in range(max_retries):
            try:
                raw_socket = socket.create_connection((host, self.GITHUB_API_PORT), timeout=10)
                context = ssl.create_default_context()
                sock = context.wrap_socket(raw_socket, server_hostname=host)
                
                sock.sendall(request)
                response = self._receive_response(sock, host == self.GITHUB_RAW_HOST)
                sock.close()
                
                # Check if we got a successful response
                if response[0] and ('200 OK' in response[0] or '201 Created' in response[0]):
                    return response
                    
                # Check for rate limiting
                if '403 Forbidden' in response[0] and 'rate limit exceeded' in response[0].lower():
                    if attempt < max_retries - 1:
                        time.sleep(retry_delay * (attempt + 1))
                        continue
                        
                return response
                
            except (socket.timeout, ConnectionError) as e:
                if attempt < max_retries - 1:
                    time.sleep(retry_delay * (attempt + 1))
                    continue
                self.logger.error(f"Connection error after {max_retries} attempts: {e}")
                return None, None
            except Exception as e:
                self.logger.error(f"Unexpected error: {e}")
                return None, None
            finally:
                try:
                    sock.close()
                except:
                    pass
        
        return None, None
            
    def clone(self):
        print(f"\nCloning repository: {self.repository}")
        print(f"Using branch: {self.branch_id}")
        
        api_path = f"/repos/{self.repository}/contents"
        if self.branch_id:
            api_path += f"?ref={self.branch_id}"

        # Get repository contents
        header, body = self._send_request("GET", api_path)
        
        if not body:
            return
            
        try:
            files = json.loads(body)
            if not isinstance(files, list):
                print(f"Unexpected response format. Expected a list of files.")
                return
                
            print(f"\nFound {len(files)} files to download")
            for file in files:
                if 'download_url' in file and file['download_url']:
                    print(f"\nProcessing {file['name']}...")
                    if file.get('size', 0) > 1024 * 1024:  # > 1MB
                        self._download_large_file(file['download_url'], file['name'])
                    else:
                        self._download_file(file['download_url'], file['name'])
                else:
                    print(f"Skipping {file['name']} (no download URL available)")
                        
        except json.JSONDecodeError as e:
            print(f"Error parsing GitHub response: {e}")
            return
        except KeyError as e:
            print(f"Unexpected response format: {e}")
            return

    def _download_file(self, url, file_name):
        print(f"Downloading {file_name}...")
        header, body = self._send_request("GET", url)
        if body is None:
            print(f"Failed to download {file_name}")
            return
            
        try:
            os.makedirs(os.path.dirname(file_name) if os.path.dirname(file_name) else '.', exist_ok=True)
            
            if isinstance(body, str):
                body = body.encode()
                
            with open(file_name, "wb") as file:
                file.write(body)
            print(f"Successfully downloaded {file_name}")
        except Exception as e:
            print(f"Error saving {file_name}: {e}")

    def _download_large_file(self, url, file_name):
        file_size = int(self._get_file_size(url))
        chunk_size = file_size // int(self.parallel_count)
        threads = []

        os.makedirs(os.path.dirname(file_name) if os.path.dirname(file_name) else '.', exist_ok=True)

        with open(file_name, "wb") as file:
            file.truncate(file_size)

        for i in range(int(self.parallel_count)):
            start = i * chunk_size
            end = start + chunk_size - 1 if i < int(self.parallel_count) - 1 else file_size - 1
            thread = threading.Thread(target=self._download_chunk, args=(url, file_name, start, end))
            thread.start()
            threads.append(thread)

        for thread in threads:
            thread.join()

    def _receive_response(self, sock, is_binary=False):
        response = b""
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            response += chunk

        parts = response.split(b"\r\n\r\n", 1)
        if len(parts) != 2:
            return response.decode(), b""
            
        header, body = parts
        
        if is_binary:
            return header.decode(), body
        try:
            return header.decode(), body.decode()
        except UnicodeDecodeError:
            return header.decode(), body

    def clone(self):
        if self.command == "clone" and not self.parallel_count:
            print("Error: parallel_count is required for clone operation")
            return

        print(f"\nCloning repository: {self.repository}")
        print(f"Using branch: {self.branch_id}")
        
        api_path = f"/repos/{self.repository}/contents"
        if self.branch_id:
            api_path += f"?ref={self.branch_id}"

        header, body = self._send_request("GET", api_path)
        if not body:
            return
        try:
            if isinstance(body, bytes):
                files = json.loads(body.decode())
            else:
                files = json.loads(body)
                
            if not isinstance(files, list):
                print(f"Unexpected response format. Expected a list of files.")
                return
                
            print(f"\nFound {len(files)} files")
            for file in files:
                if 'download_url' in file and file['download_url']:
                    exists, local_size = self._get_file_info(file['name'])
                    remote_size = file.get('size', 0)
                    
                    if exists and local_size == remote_size:
                        print(f"Skipping {file['name']} (already up to date)")
                        continue
                        
                    print(f"\nProcessing {file['name']}...")
                    if remote_size > 1024 * 1024:  # > 1MB
                        self._download_large_file(file['download_url'], file['name'])
                    else:
                        self._download_file(file['download_url'], file['name'])
                else:
                    print(f"Skipping {file['name']} (no download URL available)")
                        
        except json.JSONDecodeError as e:
            print(f"Error parsing GitHub response: {e}")
        except KeyError as e:
            print(f"Unexpected response format: {e}")

    def _download_chunk(self, url, file_name, start, end):
        headers = self.headers.copy()
        headers["Range"] = f"bytes={start}-{end}"
        
        print(f"Requesting bytes={start}-{end} for {file_name}")
        
        header, body = self._send_request("GET", url, headers)
        
        if body is None:
            print(f"Failed to download chunk {start}-{end} for {file_name}")
            return
            
        if isinstance(body, str):
            body = body.encode()
            
        with open(file_name, "r+b") as file:
            file.seek(start)
            file.write(body)


    def _get_file_size(self, url):
        headers = self.headers.copy()
        headers["Range"] = "bytes=0-0"
        header, _ = self._send_request("HEAD", url, headers)
        for line in header.split("\r\n")[1:]:
            if ": " in line:
                key, value = line.split(": ", 1)
                if key.lower() == "content-range":
                    return int(value.split("/")[1])
        return 0
        
    def branch(self):
        if not self.branch_id:
            print("Error: branch name is required for branch operation")
            return

        print(f"Creating new branch: {self.branch_id}")

        # Step 1: Retrieve the default branch name
        repo_path = f"/repos/{self.repository}"
        print(f"Fetching default branch for repository: {self.repository}")
        
        header, repo_body = self._send_request("GET", repo_path)
        
        if not repo_body:
            print("Error: No response when fetching repository details.")
            return

        try:
            repo_data = json.loads(repo_body)
            default_branch = repo_data.get("default_branch")
            if not default_branch:
                print("Error: Could not determine the default branch.")
                return
            print(f"Default branch is: {default_branch}")
        except json.JSONDecodeError:
            print("Error: Unable to parse repository information.")
            print("Response body:", repo_body)
            return

        # Step 2: Retrieve the SHA of the default branch
        sha_path = f"/repos/{self.repository}/git/refs/heads/{default_branch}"
        header, sha_body = self._send_request("GET", sha_path)
        
        if not sha_body:
            print("Error: Empty response received when fetching SHA.")
            return

        try:
            sha_data = json.loads(sha_body)
            sha = sha_data["object"]["sha"]
            print(f"SHA for {default_branch} branch: {sha}")
        except (json.JSONDecodeError, KeyError):
            print("Error: 'object' or 'sha' key is missing in the response when fetching SHA.")
            print("Response body:", sha_body)
            return

        # Step 3: Create the new branch with the obtained SHA
        try:
            path = f"/repos/{self.repository}/git/refs"
            body = json.dumps({"ref": f"refs/heads/{self.branch_id}", "sha": sha})
            
            header, response = self._send_request("POST", path, body=body)
            
            if header and "201 Created" in header:
                print(f"Successfully created branch: {self.branch_id}")
            else:
                print("Failed to create branch. Response header:", header)
                print("Response body:", response)
        except (json.JSONDecodeError, KeyError) as e:
            print(f"Error creating branch: {e}")


    def upload(self):
        if not self.file_name or not self.branch_id:
            print("Error: file_name and branch are required for upload operation")
            return
            
        if not os.path.exists(self.file_name):
            print(f"Error: File {self.file_name} not found")
            return
            
        print(f"Uploading {self.file_name} to branch: {self.branch_id}")
        path = f"/repos/{self.repository}/contents/{self.file_name}"
        
        try:
            # Try to get existing file to get its SHA
            header, body = self._send_request("GET", f"{path}?ref={self.branch_id}")
            file_sha = json.loads(body)["sha"] if body else None
        except (json.JSONDecodeError, KeyError):
            file_sha = None

        try:
            with open(self.file_name, "rb") as file:
                content = base64.b64encode(file.read()).decode()
            
            data = {
                "message": f"Upload {self.file_name}",
                "content": content,
                "branch": self.branch_id
            }
            if file_sha:
                data["sha"] = file_sha
                
            body = json.dumps(data)
            header, response = self._send_request("PUT", path, body=body)
            
            if header and ("201 Created" in header or "200 OK" in header):
                print(f"Successfully uploaded {self.file_name}")
            else:
                print("Failed to upload file")
        except Exception as e:
            print(f"Error uploading file: {e}")

    def create_pr(self):
        if not self.branch_id:
            print("Error: branch is required for create-pr operation")
            return
            
        print(f"Creating pull request from {self.branch_id} to main")
        path = f"/repos/{self.repository}/pulls"
        body = json.dumps({
            "title": "New Pull Request",
            "body": "Pull request created by PseudoGit",
            "head": self.branch_id,
            "base": "main"
        })
        
        header, response = self._send_request("POST", path, body=body)
        if header and "201 Created" in header:
            print("Successfully created pull request")
        else:
            print("Failed to create pull request")

    def list_pr(self):
        print("Listing open pull requests")
        path = f"/repos/{self.repository}/pulls?state=open"
        header, body = self._send_request("GET", path)
        
        if not body:
            return
            
        try:
            pulls = json.loads(body)
            if not pulls:
                print("No open pull requests found")
                return
                
            for pr in pulls:
                print(f"PR #{pr['number']}: {pr['title']} (state: {pr['state']})")
        except (json.JSONDecodeError, KeyError) as e:
            print(f"Error listing pull requests: {e}")

    def merge_pr(self):
        if not self.pr_number:
            print("Error: pr_number is required for merge-pr operation")
            return
            
        print(f"Merging pull request #{self.pr_number}")
        path = f"/repos/{self.repository}/pulls/{self.pr_number}/merge"
        body = json.dumps({
            "commit_title": f"Merge pull request #{self.pr_number}",
            "merge_method": "merge"
        })
        
        header, response = self._send_request("PUT", path, body=body)
        if header and "200 OK" in header:
            print(f"Successfully merged pull request #{self.pr_number}")
        else:
            print("Failed to merge pull request")

# Line based code
""" """

def validate_args(args):
    if len(args) < 2:
        print("Error: Command argument is required")
        print_usage()
        sys.exit(1)
    
    valid_commands = ['clone', 'branch', 'upload', 'create-pr', 'list-pr', 'merge-pr']
    command = args[1]
    
    if command not in valid_commands:
        print(f"Error: Invalid command '{command}'")
        print_usage()
        sys.exit(1)
    
    if len(args) < 3:
        print("Error: Repository argument is required")
        print_usage()
        sys.exit(1)
    
    if command == 'clone':
        if len(args) != 4:
            print("Error: Clone command requires repository and parallel_count")
            print_usage()
            sys.exit(1)
        try:
            parallel_count = int(args[3])
            if parallel_count < 1:
                raise ValueError
        except ValueError:
            print("Error: parallel_count must be a positive integer")
            sys.exit(1)
    
    elif command == 'branch':
        if len(args) != 4:
            print("Error: Branch command requires repository and branch name")
            print_usage()
            sys.exit(1)
    
    elif command == 'upload':
        if len(args) != 5:
            print("Error: Upload command requires repository, branch, and file_name")
            print_usage()
            sys.exit(1)
    
    elif command == 'create-pr':
        if len(args) != 4:
            print("Error: Create-pr command requires repository and branch")
            print_usage()
            sys.exit(1)
    
    elif command == 'merge-pr':
        if len(args) != 4:
            print("Error: Merge-pr command requires repository and pr_number")
            print_usage()
            sys.exit(1)
        try:
            pr_number = int(args[3])
            if pr_number < 1:
                raise ValueError
        except ValueError:
            print("Error: pr_number must be a positive integer")
            sys.exit(1)

def print_usage():
    print("\nUsage:")
    print("Clone:            python PseudoGit.py clone <repository> <parallel_count>")
    print("Branch:           python PseudoGit.py branch <repository> <branch>")
    print("Upload:           python PseudoGit.py upload <repository> <branch> <file_name>")
    print("Create PR:        python PseudoGit.py create-pr <repository> <branch>")
    print("List PR:          python PseudoGit.py list-pr <repository>")
    print("Merge PR:         python PseudoGit.py merge-pr <repository> <pr_number>")

if __name__ == "__main__":
    validate_args(sys.argv)
    
    command = sys.argv[1]
    repository = sys.argv[2]
    
    branch = None
    file_name = None
    pr_number = None
    parallel_count = None
    
    if command == 'clone':
        parallel_count = int(sys.argv[3])
    elif command == 'branch':
        branch = sys.argv[3]
    elif command == 'upload':
        branch = sys.argv[3]
        file_name = sys.argv[4]
    elif command == 'create-pr':
        branch = sys.argv[3]
    elif command == 'merge-pr':
        pr_number = int(sys.argv[3])
    
    git_client = PseudoGit(command, repository, branch, file_name, pr_number, parallel_count)
    
    # Ensure method exists before attempting to call
    method_name = command.replace('-', '_')
    if hasattr(git_client, method_name):
        print("here : ") 
        print(method_name)
        method = getattr(git_client, method_name)
        print(method)
        if callable(method):
            method()
        else:
            print(f"Error: '{method_name}' is not a callable method.")
    else:
        print(f"Error: No method '{method_name}' found in PseudoGit.")

""" 
def main():
    root = tk.Tk()
    app = PseudoGitGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
"""